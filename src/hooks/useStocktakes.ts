import { useState, useEffect, useCallback } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';
import { useAuth } from '@/contexts/AuthContext';
import type { Database } from '@/integrations/supabase/types';

type StocktakeRow = Database['public']['Tables']['stocktakes']['Row'];
type StocktakeInsert = Database['public']['Tables']['stocktakes']['Insert'];
type StocktakeUpdate = Database['public']['Tables']['stocktakes']['Update'];
type StocktakeItemRow = Database['public']['Tables']['stocktake_items']['Row'];

export interface Stocktake extends StocktakeRow {
  warehouse?: { id: string; name: string } | null;
  location?: { id: string; code: string; name: string | null } | null;
  assigned_user?: { id: string; first_name: string | null; last_name: string | null } | null;
}

export interface StocktakeItem extends StocktakeItemRow {
  item?: { id: string; item_code: string; description: string | null } | null;
  expected_location?: { id: string; code: string } | null;
  found_location?: { id: string; code: string } | null;
}

export type StocktakeStatus = 'planned' | 'in_progress' | 'completed' | 'cancelled';
export type CountStatus = 'pending' | 'found' | 'missing' | 'discrepancy' | 'resolved';

export interface StocktakeFilters {
  status?: StocktakeStatus;
  warehouseId?: string;
}

export function useStocktakes(filters?: StocktakeFilters) {
  const [stocktakes, setStocktakes] = useState<Stocktake[]>([]);
  const [loading, setLoading] = useState(true);
  const { toast } = useToast();
  const { profile } = useAuth();

  const fetchStocktakes = useCallback(async () => {
    if (!profile?.tenant_id) return;
    
    try {
      setLoading(true);
      let query = supabase
        .from('stocktakes')
        .select(`
          *,
          warehouse:warehouses!stocktakes_warehouse_id_fkey(id, name),
          location:locations!stocktakes_location_id_fkey(id, code, name),
          assigned_user:users!stocktakes_assigned_to_fkey(id, first_name, last_name)
        `)
        .eq('tenant_id', profile.tenant_id)
        .is('deleted_at', null)
        .order('scheduled_date', { ascending: false });

      if (filters?.status) {
        query = query.eq('status', filters.status);
      }
      if (filters?.warehouseId) {
        query = query.eq('warehouse_id', filters.warehouseId);
      }

      const { data, error } = await query;

      if (error) throw error;
      setStocktakes(data || []);
    } catch (error) {
      console.error('Error fetching stocktakes:', error);
      toast({
        variant: 'destructive',
        title: 'Error',
        description: 'Failed to load stocktakes',
      });
    } finally {
      setLoading(false);
    }
  }, [filters?.status, filters?.warehouseId, profile?.tenant_id, toast]);

  useEffect(() => {
    fetchStocktakes();
  }, [fetchStocktakes]);

  const createStocktake = async (data: Omit<StocktakeInsert, 'tenant_id' | 'stocktake_number'> & { stocktake_number?: string }) => {
    if (!profile?.tenant_id) throw new Error('No tenant');
    
    // stocktake_number is auto-generated by trigger, but we need to satisfy TypeScript
    const insertData = { 
      ...data, 
      tenant_id: profile.tenant_id,
      created_by: profile.id,
      stocktake_number: data.stocktake_number || '', // Will be overwritten by trigger
    };
    
    const { data: result, error } = await supabase
      .from('stocktakes')
      .insert([insertData])
      .select()
      .single();

    if (error) throw error;
    
    toast({
      title: 'Stocktake Created',
      description: `Stocktake ${result.stocktake_number} has been scheduled`,
    });
    
    await fetchStocktakes();
    return result;
  };

  const startStocktake = async (id: string) => {
    const { data: result, error } = await supabase
      .from('stocktakes')
      .update({
        status: 'in_progress',
        started_at: new Date().toISOString(),
      })
      .eq('id', id)
      .select()
      .single();

    if (error) throw error;
    await fetchStocktakes();
    return result;
  };

  const completeStocktake = async (id: string) => {
    // Calculate variance
    const { data: items } = await supabase
      .from('stocktake_items')
      .select('status')
      .eq('stocktake_id', id);

    const varianceCount = items?.filter(i => 
      i.status === 'missing' || i.status === 'discrepancy'
    ).length || 0;

    const { data: result, error } = await supabase
      .from('stocktakes')
      .update({
        status: 'completed',
        completed_at: new Date().toISOString(),
        variance_count: varianceCount,
        counted_item_count: items?.length || 0,
      })
      .eq('id', id)
      .select()
      .single();

    if (error) throw error;
    
    toast({
      title: 'Stocktake Completed',
      description: varianceCount > 0 
        ? `Completed with ${varianceCount} variance(s)`
        : 'Completed with no variances',
    });
    
    await fetchStocktakes();
    return result;
  };

  const cancelStocktake = async (id: string) => {
    const { error } = await supabase
      .from('stocktakes')
      .update({ status: 'cancelled' })
      .eq('id', id);

    if (error) throw error;
    await fetchStocktakes();
  };

  return {
    stocktakes,
    loading,
    refetch: fetchStocktakes,
    createStocktake,
    startStocktake,
    completeStocktake,
    cancelStocktake,
  };
}

// Separate hook for stocktake items
export function useStocktakeItems(stocktakeId: string) {
  const [items, setItems] = useState<StocktakeItem[]>([]);
  const [loading, setLoading] = useState(true);
  const { toast } = useToast();
  const { profile } = useAuth();

  const fetchItems = useCallback(async () => {
    if (!stocktakeId) return;
    
    try {
      setLoading(true);
      const { data, error } = await supabase
        .from('stocktake_items')
        .select(`
          *,
          item:items!stocktake_items_item_id_fkey(id, item_code, description),
          expected_location:locations!stocktake_items_expected_location_id_fkey(id, code),
          found_location:locations!stocktake_items_found_location_id_fkey(id, code)
        `)
        .eq('stocktake_id', stocktakeId)
        .order('created_at');

      if (error) throw error;
      setItems(data || []);
    } catch (error) {
      console.error('Error fetching stocktake items:', error);
      toast({
        variant: 'destructive',
        title: 'Error',
        description: 'Failed to load stocktake items',
      });
    } finally {
      setLoading(false);
    }
  }, [stocktakeId, toast]);

  useEffect(() => {
    fetchItems();
  }, [fetchItems]);

  const recordCount = async (itemId: string, data: {
    found_location_id?: string;
    counted_quantity: number;
    notes?: string;
  }) => {
    if (!profile?.id) throw new Error('No user');

    // Determine status based on count
    const item = items.find(i => i.id === itemId);
    let status: CountStatus = 'found';
    
    if (data.counted_quantity === 0) {
      status = 'missing';
    } else if (item && data.counted_quantity !== item.expected_quantity) {
      status = 'discrepancy';
    }

    const { data: result, error } = await supabase
      .from('stocktake_items')
      .update({
        found_location_id: data.found_location_id,
        counted_quantity: data.counted_quantity,
        notes: data.notes,
        status,
        counted_by: profile.id,
        counted_at: new Date().toISOString(),
      })
      .eq('id', itemId)
      .select()
      .single();

    if (error) throw error;
    await fetchItems();
    return result;
  };

  const resolveVariance = async (itemId: string, notes: string) => {
    const { data: result, error } = await supabase
      .from('stocktake_items')
      .update({
        status: 'resolved',
        notes,
      })
      .eq('id', itemId)
      .select()
      .single();

    if (error) throw error;
    await fetchItems();
    return result;
  };

  return {
    items,
    loading,
    refetch: fetchItems,
    recordCount,
    resolveVariance,
  };
}
